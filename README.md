# Animation in Flutter

Flutter makes it very easy for you to work with animations using implicit animations.

These are implicitly animated widgets, where animations are managed by the Flutter framework. You don't have to do much. Many widgets that you commonly use in Flutter, such as containers, opacity, align, and so on have animated counterparts. **Animatable** widgets start with the Animated prefix and can be used just like their corresponding regular widgets. Except, of course, these can be animated, and the way you do it is you set the target value for an animatable property, and when the target value changes, the widget is automatically animated as it takes on this new value for the property, be it height, width, color, anything. Implicit animations allow you a whole range of animations that you can use. But sometimes, you might want more control over the animations, and then you may choose to use tween animations.

Tween here refers to in between. It's a short form for in between. And this is a kind of animation that gives the developer much more control. With tween animations, you specify the starting point for an animation, an ending point, and a curve to get from the starting point to the ending point. You use the curve associated with the tween to specify the timing as well as the speed of the animation. Here is a way to visualize how tweens work. Let's say, you have an object at its starting point and its ending point. Now, you have to think about how do you get from the start to end, that is the tween or the in between. Now, you might say that I want to get from the start to the end in a straight line. So, you'll generate values, so that the object is animated along the straight line.

Or you might say I want to get from the start to the end along a curve. In such a case, your tween would generate a different set of values, so that the animation progresses along this curve. When you use tween animations, the animation values allow you to specify the path from the starting point till the end. Tween animations use an object known as the AnimationController to control the animation when the animation starts, whether it can be stopped, whether it goes in reverse, and so on. Each animation has a status and a corresponding value. The value of an animation object can be thought of as the current value of the animatable property. So, let's say, you're animating the color to go from one shade to another, an intermediate value of the color property, well, that is the animation value.

The animation status has four possible states, ** dismissed, forward, reverse, and completed **. Every animation in Flutter uses an AnimationController. In the case of implicit animations, this AnimationController is hidden behind the scenes. You don't really interact with it as a developer. For explicit animations, you directly use the AnimationController. What can the AnimationController do? Well, it can help you define your animations. The AnimationController is also responsible for generating values that you can use to run your animation. The AnimationController allows you to register listeners for events and status changes.

And the AnimationController offers you play and other sequence controls for stop, reset, and so on. The AnimationController object is responsible for generating values that control the animation. By default, the AnimationController will only generate values between 0.0 and 1.0. But your use case or your scenario might have different beginning and end values. They may not be 0 and 1. And this is why in Flutter, you use an AnimationController along with a tween. AnimationControllers can use tweens to generate values that are specific to your use case, between 100 and 150, between red and blue, anything.

## Basic Animation

This MaterialApp (basic_animation) has a Scaffold. And its body property is set to the stateful widget called BasicAnimation. Now, let's take a look at this BasicAnimation stateful widget. you can see that BasicAnimation is a StatefulWidget. The state variables for this widget are just the width and height of the square that is displayed. Initially, I've set the width and height to be both equal to 50 pixels.  I have a Column widget, it has two children, an Expanded widget  and a Padding. Within the Expanded widget, I have a centered Container. Observe that the width and the height of this container are set using our state variables, _width and _height. Now, this container has alignment center and a BoxDecoration that sets the color of this container to lightGreenAccent, that is that box that you see at the center of the screen in the Emulator. This Padding widget contains within it a Row and this Row has two buttons within Expanded widgets. The first ElevatedButton is the Shrink button. Observe that I have a callback for the onPressed property. All I do when you click on this button is to reduce the width and height of the square.

This is our manual animation. Let's see how that works. I'm going to head over to the app and click on Grow several times. Each time I click on the Grow button, observe that the size of the square grows. So, it's kind of animated and it grows. This animation is not automatic, it's manual. Let's try shrinking the square. I'm going to click on Shrink several times, and you can see that the square gets smaller as I reduce its width and height.

It would have been much more fun if you could have used a slider to change the size of the square, that seems much more natural. I'm going to go ahead and update the code associated with this BasicAnimationState class to include a slider. You can see the slider at the bottom. That's what we'll use to grow and shrink the box. Now, let's take a look at the code here. Since I'm going to be animating a square, I decided to be a little more smart about it. I have a single member variable for the state class, that is the _sliderValue on line 37. I've set the _sliderValue to 50 to start off with.
