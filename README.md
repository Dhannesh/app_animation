# Animation in Flutter

Flutter makes it very easy for you to work with animations using implicit animations.

These are implicitly animated widgets, where animations are managed by the Flutter framework. You don't have to do much. Many widgets that you commonly use in Flutter, such as containers, opacity, align, and so on have animated counterparts. **Animatable** widgets start with the Animated prefix and can be used just like their corresponding regular widgets. Except, of course, these can be animated, and the way you do it is you set the target value for an animatable property, and when the target value changes, the widget is automatically animated as it takes on this new value for the property, be it height, width, color, anything. Implicit animations allow you a whole range of animations that you can use. But sometimes, you might want more control over the animations, and then you may choose to use tween animations.

Tween here refers to in between. It's a short form for in between. And this is a kind of animation that gives the developer much more control. With tween animations, you specify the starting point for an animation, an ending point, and a curve to get from the starting point to the ending point. You use the curve associated with the tween to specify the timing as well as the speed of the animation. Here is a way to visualize how tweens work. Let's say, you have an object at its starting point and its ending point. Now, you have to think about how do you get from the start to end, that is the tween or the in between. Now, you might say that I want to get from the start to the end in a straight line. So, you'll generate values, so that the object is animated along the straight line.

Or you might say I want to get from the start to the end along a curve. In such a case, your tween would generate a different set of values, so that the animation progresses along this curve. When you use tween animations, the animation values allow you to specify the path from the starting point till the end. Tween animations use an object known as the AnimationController to control the animation when the animation starts, whether it can be stopped, whether it goes in reverse, and so on. Each animation has a status and a corresponding value. The value of an animation object can be thought of as the current value of the animatable property. So, let's say, you're animating the color to go from one shade to another, an intermediate value of the color property, well, that is the animation value.

The animation status has four possible states, ** dismissed, forward, reverse, and completed **. Every animation in Flutter uses an AnimationController. In the case of implicit animations, this AnimationController is hidden behind the scenes. You don't really interact with it as a developer. For explicit animations, you directly use the AnimationController. What can the AnimationController do? Well, it can help you define your animations. The AnimationController is also responsible for generating values that you can use to run your animation. The AnimationController allows you to register listeners for events and status changes.

And the AnimationController offers you play and other sequence controls for stop, reset, and so on. The AnimationController object is responsible for generating values that control the animation. By default, the AnimationController will only generate values between 0.0 and 1.0. But your use case or your scenario might have different beginning and end values. They may not be 0 and 1. And this is why in Flutter, you use an AnimationController along with a tween. AnimationControllers can use tweens to generate values that are specific to your use case, between 100 and 150, between red and blue, anything.

## Basic Animation

This MaterialApp (basic_animation) has a Scaffold. And its body property is set to the stateful widget called BasicAnimation. Now, let's take a look at this BasicAnimation stateful widget. you can see that BasicAnimation is a StatefulWidget. The state variables for this widget are just the width and height of the square that is displayed. Initially, I've set the width and height to be both equal to 50 pixels.  I have a Column widget, it has two children, an Expanded widget  and a Padding. Within the Expanded widget, I have a centered Container. Observe that the width and the height of this container are set using our state variables, _width and _height. Now, this container has alignment center and a BoxDecoration that sets the color of this container to lightGreenAccent, that is that box that you see at the center of the screen in the Emulator. This Padding widget contains within it a Row and this Row has two buttons within Expanded widgets. The first ElevatedButton is the Shrink button. Observe that I have a callback for the onPressed property. All I do when you click on this button is to reduce the width and height of the square.

This is our manual animation. Let's see how that works. I'm going to head over to the app and click on Grow several times. Each time I click on the Grow button, observe that the size of the square grows. So, it's kind of animated and it grows. This animation is not automatic, it's manual. Let's try shrinking the square. I'm going to click on Shrink several times, and you can see that the square gets smaller as I reduce its width and height.

It would have been much more fun if you could have used a slider to change the size of the square, that seems much more natural. I'm going to go ahead and update the code associated with this BasicAnimationState class to include a slider. You can see the slider at the bottom. That's what we'll use to grow and shrink the box. Now, let's take a look at the code here. Since I'm going to be animating a square, I decided to be a little more smart about it. I have a single member variable for the state class, that is the _sliderValue on line 37. I've set the _sliderValue to 50 to start off with.

## Progressing Towards Implicit Animations
It'd be really cool if all you had to do was click a button and the square would grow automatically to a certain size. You click another button, and the square would shrink automatically to a smaller size. Well, this is exactly what we are going to accomplish in the first part of this demo using a timer. And in the second part of this demo, we'll see how we can use implicit animations in Flutter to achieve the same thing in a much more simple manner.
First, let's update the code that I have here on screen. I'm going to update this BasicAnimationState class, so that I have a new UI setup. Now, this uses a timer, which means I need to add an import statement. So, I'm going to the top of my page here and add an import for dart:async.
The dart:async library has a timer utility that we can use to update the sides of our square at periodic intervals. With this done, let the app reload, so that you can see what the UI looks like. I have the same square, the light green accent square, and I have three buttons at the bottom, Shrink, Stop, and Grow. The Shrink button will shrink the square down to a minimum size. The Stop button will stop the shrink animation. The Grow button will grow the size of the square to a maximum size, and you can stop the growth as well using the Stop button. Let's take a look at what updates I've made to the code. The BasicAnimationState class now has a variable called side that is set to 50. In addition, it also holds a timer object that's defined on line 40 that's initially set to null.
The first button we'll look at is the Shrink ElevatedButton. Each time you click or press that button, we'll cancel whatever timer was previously running. If no timer was set up earlier, this cancel doesn't really do anything. I set up a new timer that will fire at regular intervals using Timer.periodic. The Duration that I pass into this timer is 100 milliseconds. This means that this timer will invoke the callback that I have specified every 100 milliseconds. And within the callback, all we do is call setState and decrement the side of the square by two pixels. 

I'll now scroll down a little bit further, and let's take a look at the Stop button. The onPressed handler simply updates the state of the timer. I call timer?.cancel() whenever we hit Stop. Cancelling the timer essentially stops the timer callback from being invoked and causes the box to stop growing or stop shrinking. and you can see how I wire up the grow button. This is the ElevatedButton. The onPressed handler basically first calls timer?.cancel(). So, whatever periodicity that we had set up earlier on the timer to grow or shrink, the box will be cancelled, and I set up a new periodic callback. Every 100 milliseconds the callback will be invoked, and all we do within the callback is call setState and decrement the size of the square by 2 pixels. Well, we've understood the code, let's see this in action.

### Implicit Animation
Let's see how we would accomplish the same growing and shrinking of our box using an implicit animation. Flutter widgets that support implicit animations that is built-in animations start with an animated prefix. So, if you have a container, an **AnimatedContainer** will support implicit animations. If you have a padding widget, AnimatedPadding will support implicit animations. An align widget, **AnimatedAlign** supports implicit animations. Let's take a look at our AnimatedContainer. Observe that I've set the width and height of the container to be equal to the side state variable. A new property, the duration. Here, I've set the duration to be 3000 milliseconds or 3 seconds. Now, what does this mean? In an AnimatedContainer, any time you change any of the properties of the container, and here we'll be changing the width and the height, it'll animate to the new set of properties. So, it'll animate to its new property value using the duration. So, here in our case, it'll animate to the new width and height in 3 seconds.

Whatever the current value of the side of the box, the AnimatedContainer will animate it to have a new side, which is equal to 20 pixels within 3 seconds. Notice the onPressed handler, where I set the state of the side variable to be 300. So, no matter the current size of the box, it'll animate to have a side of 300 within the duration specified, 3 seconds. With implicit animations, all you have to do is specify what you want the final value of a property to be and Flutter takes care of the animation. You don't have to do much.
## Building Implicit Animations with AnimatedContainer
We'll use an implicit animation on this AnimatedContainer (animated_container1.dart), which has set the background to change the color of the background. When we click on the floating action button, we'll toggle between the red to the green color and then from green back to red. MyAnimatedContainer is a stateful widget.The only state variable is the Color variable initially set the color to be red. And this is something that we'll update using an implicit animation. this AnimatedContainer spans the entire screen, that's why I haven't specified a height and width. The color of this container is set using the color state variable. And I've set the duration property to 2500 milliseconds. So, whatever animation is applied to this container will basically take place over 2.5 seconds.
The animation will be triggered by the floatingActionButton.  All it does is call setState. Ensuring that the animation progresses nicely from green to red and from red to green, well, that's up to Flutter. If you want to configure how fast or slowly your animation runs, you can change the duration. Notice I've set the properties width, height, and color using the state variables, and the duration of the animation is once again 2500 milliseconds or 2.5 seconds.

I'll scroll down and let's take a look at the floatingActionButton that will trigger the animation. The onPressed handler of this floatingActionButton updates the state of the container. If the width was originally equal to 50, we'll set the width to be the width of the entire screen that we access using MediaQuery.of(context). If the width is not 50, we set it to 50.  We do something similar with the height. I now have a small red box at the center of my screen. I'm going to click on the floating action button, and this should now basically change color as well as grow to fill up the entire screen. Animating multiple properties is kind of fun. I'll click on the floating action button once again, and you should find that the container shrinks to be a smaller size and red in color. Play around with this. You see that implicit animations make it very easy for you to animate your widgets.

## Configuring Animation Curves
Now, the width and the height of the container are animated, and they're set using the state variables width and height. I set the color of the container. But because the container holds an image. The image embedded within this container is an AssetImage. It's images/tie. a jpg file that I've placed within the images subfolder. Make sure you have the right entry in the pubspec.yaml file to ensure that you can access these image assets. I set the duration of the animation on this container to 2.5 seconds or 2500 milliseconds. Observe that the onPressed handler is the same as before. I changed the width to fill up the screen if it's 100 or I shrink it to a 100. I change the height to fill up the scene if it's equal to a 100, otherwise I shrink it to a 100. And I change the color from red to green and back. The main difference here is that our container holds an image. I'm going to click on the floating action button, and you can see that the container grows and the image, kind of, has a zoom-in effect. And I click on the floating action button again, the container shrinks. Now, so far, all of our animations on the container have been linear animations. That is, the animation changes linearly over time.
https://api.flutter.dev/flutter/animation/Curves-class.html.
So, if the animation is over say 3 seconds, the rate of change of the animated property is constant over all three seconds. But this need not be the case. You can actually control how the animation changes over time.
the way you do this is by using the **Curves class**.

Now, here is the Flutter documentation documenting the different types of curves that you can use with implicit animations. For each curve along the x-axis, we have the rate of change of time. Along the y-axis, we have how the property X that you are varying changes. And just a glance at this page will show you all of the different curves that are available, the **bounceIn**, the **bounceInOut**, the **bounceOut**, the **decelerate**, the **accelerate**. All these different curves can help you make your animations more interesting. Now, by default, all Flutter animations use the linear curve. So, I'm going to click on Curves.linear, and you'll see how the animation progresses linearly over time. Now, this is quite fine, but some other curve might be more interesting. Let's click on Curves.elasticIn, and you'll see how it kind of has an elasticity bouncy quality.

This is how your animation will progress. I suggest you play around with the curves on this page to get an idea of how you can have your animations progress, easeInOutBack, easeOut. All of these are curves that you can use with your animations in Flutter. Now, let's switch back to our code and try out a few different animation curves. And the way you set up curves for your animation is very straightforward, simply set the curve property on your implicitly animated widget. I'm going to click on the floating action button here, and this is how the animation progresses. Let's click on the button once again and shrink our image back. And you can see that the progress is very slow at the middle of the animation and fast at the beginning and the end. Let's try one last curve, the easeInBack. Observe how the image grows, it shrinks and then expands to its final size. Let's click on the button once again, and you can see that it kind of pulls out and then shrinks to the smaller size.

