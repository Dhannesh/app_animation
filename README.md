# Animation in Flutter

Flutter makes it very easy for you to work with animations using implicit animations.

These are implicitly animated widgets, where animations are managed by the Flutter framework. You don't have to do much. Many widgets that you commonly use in Flutter, such as containers, opacity, align, and so on have animated counterparts. **Animatable** widgets start with the Animated prefix and can be used just like their corresponding regular widgets. Except, of course, these can be animated, and the way you do it is you set the target value for an animatable property, and when the target value changes, the widget is automatically animated as it takes on this new value for the property, be it height, width, color, anything. Implicit animations allow you a whole range of animations that you can use. But sometimes, you might want more control over the animations, and then you may choose to use tween animations.

Tween here refers to in between. It's a short form for in between. And this is a kind of animation that gives the developer much more control. With tween animations, you specify the starting point for an animation, an ending point, and a curve to get from the starting point to the ending point. You use the curve associated with the tween to specify the timing as well as the speed of the animation. Here is a way to visualize how tweens work. Let's say, you have an object at its starting point and its ending point. Now, you have to think about how do you get from the start to end, that is the tween or the in between. Now, you might say that I want to get from the start to the end in a straight line. So, you'll generate values, so that the object is animated along the straight line.

Or you might say I want to get from the start to the end along a curve. In such a case, your tween would generate a different set of values, so that the animation progresses along this curve. When you use tween animations, the animation values allow you to specify the path from the starting point till the end. Tween animations use an object known as the AnimationController to control the animation when the animation starts, whether it can be stopped, whether it goes in reverse, and so on. Each animation has a status and a corresponding value. The value of an animation object can be thought of as the current value of the animatable property. So, let's say, you're animating the color to go from one shade to another, an intermediate value of the color property, well, that is the animation value.

The animation status has four possible states, ** dismissed, forward, reverse, and completed **. Every animation in Flutter uses an AnimationController. In the case of implicit animations, this AnimationController is hidden behind the scenes. You don't really interact with it as a developer. For explicit animations, you directly use the AnimationController. What can the AnimationController do? Well, it can help you define your animations. The AnimationController is also responsible for generating values that you can use to run your animation. The AnimationController allows you to register listeners for events and status changes.

And the AnimationController offers you play and other sequence controls for stop, reset, and so on. The AnimationController object is responsible for generating values that control the animation. By default, the AnimationController will only generate values between 0.0 and 1.0. But your use case or your scenario might have different beginning and end values. They may not be 0 and 1. And this is why in Flutter, you use an AnimationController along with a tween. AnimationControllers can use tweens to generate values that are specific to your use case, between 100 and 150, between red and blue, anything.

## Basic Animation

This MaterialApp (basic_animation) has a Scaffold. And its body property is set to the stateful widget called BasicAnimation. Now, let's take a look at this BasicAnimation stateful widget. you can see that BasicAnimation is a StatefulWidget. The state variables for this widget are just the width and height of the square that is displayed. Initially, I've set the width and height to be both equal to 50 pixels.  I have a Column widget, it has two children, an Expanded widget  and a Padding. Within the Expanded widget, I have a centered Container. Observe that the width and the height of this container are set using our state variables, _width and _height. Now, this container has alignment center and a BoxDecoration that sets the color of this container to lightGreenAccent, that is that box that you see at the center of the screen in the Emulator. This Padding widget contains within it a Row and this Row has two buttons within Expanded widgets. The first ElevatedButton is the Shrink button. Observe that I have a callback for the onPressed property. All I do when you click on this button is to reduce the width and height of the square.

This is our manual animation. Let's see how that works. I'm going to head over to the app and click on Grow several times. Each time I click on the Grow button, observe that the size of the square grows. So, it's kind of animated and it grows. This animation is not automatic, it's manual. Let's try shrinking the square. I'm going to click on Shrink several times, and you can see that the square gets smaller as I reduce its width and height.

It would have been much more fun if you could have used a slider to change the size of the square, that seems much more natural. I'm going to go ahead and update the code associated with this BasicAnimationState class to include a slider. You can see the slider at the bottom. That's what we'll use to grow and shrink the box. Now, let's take a look at the code here. Since I'm going to be animating a square, I decided to be a little more smart about it. I have a single member variable for the state class, that is the _sliderValue on line 37. I've set the _sliderValue to 50 to start off with.

## Progressing Towards Implicit Animations
It'd be really cool if all you had to do was click a button and the square would grow automatically to a certain size. You click another button, and the square would shrink automatically to a smaller size. Well, this is exactly what we are going to accomplish in the first part of this demo using a timer. And in the second part of this demo, we'll see how we can use implicit animations in Flutter to achieve the same thing in a much more simple manner.
First, let's update the code that I have here on screen. I'm going to update this BasicAnimationState class, so that I have a new UI setup. Now, this uses a timer, which means I need to add an import statement. So, I'm going to the top of my page here and add an import for dart:async.
The dart:async library has a timer utility that we can use to update the sides of our square at periodic intervals. With this done, let the app reload, so that you can see what the UI looks like. I have the same square, the light green accent square, and I have three buttons at the bottom, Shrink, Stop, and Grow. The Shrink button will shrink the square down to a minimum size. The Stop button will stop the shrink animation. The Grow button will grow the size of the square to a maximum size, and you can stop the growth as well using the Stop button. Let's take a look at what updates I've made to the code. The BasicAnimationState class now has a variable called side that is set to 50. In addition, it also holds a timer object that's defined on line 40 that's initially set to null.
The first button we'll look at is the Shrink ElevatedButton. Each time you click or press that button, we'll cancel whatever timer was previously running. If no timer was set up earlier, this cancel doesn't really do anything. I set up a new timer that will fire at regular intervals using Timer.periodic. The Duration that I pass into this timer is 100 milliseconds. This means that this timer will invoke the callback that I have specified every 100 milliseconds. And within the callback, all we do is call setState and decrement the side of the square by two pixels. 

I'll now scroll down a little bit further, and let's take a look at the Stop button. The onPressed handler simply updates the state of the timer. I call timer?.cancel() whenever we hit Stop. Cancelling the timer essentially stops the timer callback from being invoked and causes the box to stop growing or stop shrinking. and you can see how I wire up the grow button. This is the ElevatedButton. The onPressed handler basically first calls timer?.cancel(). So, whatever periodicity that we had set up earlier on the timer to grow or shrink, the box will be cancelled, and I set up a new periodic callback. Every 100 milliseconds the callback will be invoked, and all we do within the callback is call setState and decrement the size of the square by 2 pixels. Well, we've understood the code, let's see this in action.

### Implicit Animation
Let's see how we would accomplish the same growing and shrinking of our box using an implicit animation. Flutter widgets that support implicit animations that is built-in animations start with an animated prefix. So, if you have a container, an **AnimatedContainer** will support implicit animations. If you have a padding widget, AnimatedPadding will support implicit animations. An align widget, **AnimatedAlign** supports implicit animations. Let's take a look at our AnimatedContainer. Observe that I've set the width and height of the container to be equal to the side state variable. A new property, the duration. Here, I've set the duration to be 3000 milliseconds or 3 seconds. Now, what does this mean? In an AnimatedContainer, any time you change any of the properties of the container, and here we'll be changing the width and the height, it'll animate to the new set of properties. So, it'll animate to its new property value using the duration. So, here in our case, it'll animate to the new width and height in 3 seconds.

Whatever the current value of the side of the box, the AnimatedContainer will animate it to have a new side, which is equal to 20 pixels within 3 seconds. Notice the onPressed handler, where I set the state of the side variable to be 300. So, no matter the current size of the box, it'll animate to have a side of 300 within the duration specified, 3 seconds. With implicit animations, all you have to do is specify what you want the final value of a property to be and Flutter takes care of the animation. You don't have to do much.
## Building Implicit Animations with AnimatedContainer
We'll use an implicit animation on this AnimatedContainer (animated_container1.dart), which has set the background to change the color of the background. When we click on the floating action button, we'll toggle between the red to the green color and then from green back to red. MyAnimatedContainer is a stateful widget.The only state variable is the Color variable initially set the color to be red. And this is something that we'll update using an implicit animation. this AnimatedContainer spans the entire screen, that's why I haven't specified a height and width. The color of this container is set using the color state variable. And I've set the duration property to 2500 milliseconds. So, whatever animation is applied to this container will basically take place over 2.5 seconds.
The animation will be triggered by the floatingActionButton.  All it does is call setState. Ensuring that the animation progresses nicely from green to red and from red to green, well, that's up to Flutter. If you want to configure how fast or slowly your animation runs, you can change the duration. Notice I've set the properties width, height, and color using the state variables, and the duration of the animation is once again 2500 milliseconds or 2.5 seconds.

I'll scroll down and let's take a look at the floatingActionButton that will trigger the animation. The onPressed handler of this floatingActionButton updates the state of the container. If the width was originally equal to 50, we'll set the width to be the width of the entire screen that we access using MediaQuery.of(context). If the width is not 50, we set it to 50.  We do something similar with the height. I now have a small red box at the center of my screen. I'm going to click on the floating action button, and this should now basically change color as well as grow to fill up the entire screen. Animating multiple properties is kind of fun. I'll click on the floating action button once again, and you should find that the container shrinks to be a smaller size and red in color. Play around with this. You see that implicit animations make it very easy for you to animate your widgets.

## Configuring Animation Curves
Now, the width and the height of the container are animated, and they're set using the state variables width and height. I set the color of the container. But because the container holds an image. The image embedded within this container is an AssetImage. It's images/tie. a jpg file that I've placed within the images subfolder. Make sure you have the right entry in the pubspec.yaml file to ensure that you can access these image assets. I set the duration of the animation on this container to 2.5 seconds or 2500 milliseconds. Observe that the onPressed handler is the same as before. I changed the width to fill up the screen if it's 100 or I shrink it to a 100. I change the height to fill up the scene if it's equal to a 100, otherwise I shrink it to a 100. And I change the color from red to green and back. The main difference here is that our container holds an image. I'm going to click on the floating action button, and you can see that the container grows and the image, kind of, has a zoom-in effect. And I click on the floating action button again, the container shrinks. Now, so far, all of our animations on the container have been linear animations. That is, the animation changes linearly over time.
https://api.flutter.dev/flutter/animation/Curves-class.html.
So, if the animation is over say 3 seconds, the rate of change of the animated property is constant over all three seconds. But this need not be the case. You can actually control how the animation changes over time.
the way you do this is by using the **Curves class**.

Now, here is the Flutter documentation documenting the different types of curves that you can use with implicit animations. For each curve along the x-axis, we have the rate of change of time. Along the y-axis, we have how the property X that you are varying changes. And just a glance at this page will show you all of the different curves that are available, the **bounceIn**, the **bounceInOut**, the **bounceOut**, the **decelerate**, the **accelerate**. All these different curves can help you make your animations more interesting. Now, by default, all Flutter animations use the linear curve. So, I'm going to click on Curves.linear, and you'll see how the animation progresses linearly over time. Now, this is quite fine, but some other curve might be more interesting. Let's click on Curves.elasticIn, and you'll see how it kind of has an elasticity bouncy quality.

This is how your animation will progress. I suggest you play around with the curves on this page to get an idea of how you can have your animations progress, easeInOutBack, easeOut. All of these are curves that you can use with your animations in Flutter. Now, let's switch back to our code and try out a few different animation curves. And the way you set up curves for your animation is very straightforward, simply set the curve property on your implicitly animated widget. I'm going to click on the floating action button here, and this is how the animation progresses. Let's click on the button once again and shrink our image back. And you can see that the progress is very slow at the middle of the animation and fast at the beginning and the end. Let's try one last curve, the easeInBack. Observe how the image grows, it shrinks and then expands to its final size. Let's click on the button once again, and you can see that it kind of pulls out and then shrinks to the smaller size.

## Controlling Multiple Animations
I've already set up the code for multiple animations in the multiple_animation_container.dart file, you can see that within an app page, we have two different images. The image on top is of a top, a dress top, and the image at the bottom is an image of jeans. In our first iteration of this code, let's see how the animations work. I'm going to click on the play button here. Observe that both images shrink together and if you click on the same play button again, you can see that both images grow again together simultaneously. Let's take a look at the code to actually wire up these animations. We can look at the state class for this AnimatedContainerPage. Observe the state member variables. I have the ViewState that is initially set to expanded. 

Let's take a look at the two animated containers. This is the AnimatedContainer for the image on top. You can see that the width and height of the container are set based on the _viewState. If the ViewState is expanded, we set the width and height to be equal to the _expandedSize. If it's shrunk, then we set it to be equal to the _shrunkSize. The image within the container is specified as a DecorationImage.

I'm going to scroll down further, so you can see the second AnimatedContainer. You can see that its properties are exactly the same as the first, width and height are based on _viewState, The DecorationImage  displays a number of pairs of jeans. The duration once again is 3 seconds and the curve is linear and further down, the floatingActionButton that triggers the animation simply calls setState within its onPressed handler. It changes the _viewState. If the _viewState was originally expanded, it sets it to ViewState.shrunk, otherwise it sets it to ViewState.expanded.

When you click on the floating action button, the images will shrink simultaneously. And you click on the button once again, they'll expand simultaneously. I think these animations are kind of boring. 

Let's tweak a few properties to make them more interesting. My objective here is to chain the two animations together, so that the container on top is animated first. And after that, we animate the container with the jeans image at the bottom. The first thing I need to set up to achieve this is to have different state variables for the top view and the jeans view. I have two ViewState variables, the _topViewState and the _jeansViewState. Both of them are initially set to shrunk. The **onEnd** callback will be invoked when the animation for this container has ended. Now, within the onEnd callback, I call setState to update the ViewState for the jeans image. If the _jeansViewState was originally expanded, I'll go ahead and set it to the shrunk ViewState, otherwise I'll set it to expanded. So, the _jeansViewState is only updated after the animation for the top container is at its end.

A last change that I have made here is that of floatingActionButton. On its onPressed handler, I call setState, but I only update the state for the top container. you can see that if the _topViewState is expanded, I set it to shrunk, otherwise I set it to expanded. for the top container ends, that will automatically trigger the animation for the bottom container. Let's try this. I'm going to click on the button to trigger the animation. The top container gets animated first, and then the bottom container is animated after that. Let's try this again. The top container will shrink first, and the bottom container will expand after that. Thus, by having different states for the two containers and using the properties available on the AnimatedContainer, we have chained together animations to give a much more interesting effect.

## Using AnimatedOpacity and AnimatedCrossFade
The AnimatedOpacity. As its name suggests, the AnimatedOpacity widget allows us to animate the opacity of any widget that it wraps. Animating the opacity allows you to set up a peekaboo effect in your code, where you perform some kind of gesture, and then suddenly you see something pop-up or another gesture makes it disappear, hidden from view. The _opacity is initially set to 0.0. An _opacity of 0.0 means the element is fully transparent, that is, it is invisible.

The actual layout of the user interface is in the build method. Within the body of the Scaffold, you can see that I have an InkResponse widget. Remember the InkResponse responds to tap gestures and each time you tap on it, it'll give you a highlight effect and that's why I've used the InkResponse. The onTap handler, when you click on this InkResponse widget, simply changes the state of your _opacity. If _opacity was previously 0.0, it'll set the _opacity to 1, otherwise it'll switch the _opacity back from 1 to 0.0. 
This Container contains a Column widget. And if you look at the first child of the Column widget, you see that child is either a Text that says Tap me! when _opacity is 0, otherwise it's just a Container. Essentially, this means when the underlying widget is invisible, has an _opacity of 0, you'll be able to see the Text that says Tap me! Otherwise, you'll just see a Container, which has no color, is completely transparent. That means you'll be able to view the underlying widget that's wrapped in an AnimatedOpacity widget.
Now, that we understand the code, let's go ahead and run this app and see how it works. I'm going to go ahead and tap on this box that says Tap me! And you should find that the _opacity changes over the course of a second. The underlying image and text goes from being transparent to opaque, and you can now see what's underneath an image and a congratulatory message saying you get some percentage off on your order.

you can see in animated_cross_fade_page.dart that it has one Boolean state variable, _showFirst set to true. This is the variable that I'll use to track which widget is being displayed. _showFirst set to true means that I'll display the first widget on screen first, and then when the user taps on it, I'll display the second. I'll update the state to do so.
Let's go straight to the **AnimatedCrossFade** widget. You specify the children of the AnimatedCrossFade using two properties, firstChild and secondChild. The firstChild property is an InkWell, which means it responds to a tap gesture. And the InkWell contains within it a Card material widget that contains an Image. So, essentially, this firstChild is a widget that responds to tap gestures and shows some kind of highlighting on the tab and contains an image. What's interesting here is the onTap handler. All I do here is call setState and toggle the _showFirst Boolean. If _showFirst was originally true, it will be set to false. If it was false, it will be set to true.
The secondChild for this AnimatedCrossFade widget is also an InkWell that responds to tap gestures. The InkWell wraps a Card widget , which then further wraps an Image. The onTap handler for the InkWell also updates the _showFirst variable. It toggles it. If it was true, it will be set to false. If it's false, it'll be set to true.

So, essentially, you can tap on both of the widgets displayed by the AnimatedCrossFade, and the crossfade should animate between the two children. There are a few more properties that you need to set. The crossFadeState property tells this widget whether the firstChild should be displayed or the secondChild should be displayed. If showFirst is true, set the CrossFadeState to showFirst, otherwise set it to showSecond. And the duration of this animation is just 1 second.

## Playing with the AnimatedSlide
you'll see that the only state variable that this particular animated_slide_page.dart state has is the Offset. The offset is originally set to Offset.zero. An offset is an immutable two-dimensional floating point offset and can be used as a vector that can be applied to coordinates. I have the _slideLeft and _slideRight methods. Notice within _slideLeft, I subtract (1, 0) from the original offset. This means I'll decrement the X value by 1, so the car will move to the left. _slideRight increments the offset by an Offset value of (1, 0), which means I increment the X value by 1, so the car will move one unit to the right. 

If you scroll down, you'll see that our AnimatedSlide simply holds an Image. This Image  is an image of a car and it's available in the images folder. This should be part of the resources that you have for this video. The AnimatedSlide animates the offset property that is set using the state variable and the duration for this animation is 1 seconds. The first ElevatedButton's onPressed handler will slide the car left. The second ElevatedButton's onPressed handler will slide the car right.

All that's left is to run the app and play around with the AnimatedSlide. I'm now going to click on the different buttons at random. Let's start with the _slideUp. You'll see that the car will give a bouncing motion before it moves up. The _slideDown brings the car back down to its original position. So, if you click on the button multiple times, it will, of course, move further along in that direction. And you can, kind of, click on them quickly, and you'll find that the car moves to different positions in the screen.

## Using the Animation Controller
In Flutter, every animation is controlled using an **animation controller**. It's just that in the implicitly animated widgets that we've worked with so far, the animation controller is behind the scenes handled by Flutter. We don't interact with it directly. But if you want to use tweening and other advanced animation effects.
The animation controller is what allows you to control and manipulate your animation. It lets you perform tasks, such as playing an animation in forward or reverse, stopping an animation, defining bounds for your animation, and so on. 

The AnimationController, by default, linearly produces values that range from 0.0 to 1.0 within the duration. So, within the 2.5 seconds of the animation, the AnimationController will generate values from 0 to 1. These generated values from 0 to 1 are given to your app whenever your device is ready to display a new frame.

A TickerProvider is basically just a factory to create Ticker objects. And a Ticker object knows how to register itself with a scheduler and then fire a callback for each frame, so that your animation can be updated for each frame. The AnimationController actually uses this TickerProvider to step through the animation that it controls. Another interesting detail of the Ticker objects that you need to keep in mind is that these Ticker objects only tick when the current tree is enabled. So, if your widgets are disabled or hidden, they will not tick. That means your animations will not take up compute resources.

Now, this AnimationController constructor has the red underline because it asks for the vsync argument, and the vsync argument is a reference to the TickerProvider. So, where do we get this TickerProvider from? Well, we use a mixin. I'm going to update this State class, so that it extends the state and uses a mixin, so with SingleTickerProviderStateMixin. And really, with this mixin, you have the TickerProvider that your AnimationController needs. The SingleTickerProviderStateMixin is the right one to use if you have just a single AnimationController in your class. For multiple animation controllers, you need to use a different class, the TickerProviderStateMixin.

Now, remember that our AnimationController needs access to this TickerProvider and we pass an instance of the current object to the vsync property in the _animationController constructor. The vsync property is set to this, the current instance of the state object. Now, remember that your AnimationController is controlling and managing your animations. it's very important that you dispose off the AnimationController in the dispose method of your StatefulWidget as I've done here within the dispose method.

The AnimationController, when activated, will generate values between 0 and 1. Now, these values are accessible in the value member variable of the AnimationController. It turns out that the setState method does not really need to actually change the state.  I call _animationController.addListener. And as the AnimationController value changes, this listener will be invoked. And within the listener, I call setState and all I do within setState is print out the current animation value. I only print out the value generated, I'm not actually changing any other state. setState will automatically redraw the widget, which will take the new values from the AnimationController for the height and width. AnimationController generates values between 0 and 1. But if our shape has height and width of 0 and 1, well, we won't really be able to see anything, it will be too tiny. So, I'm going to scale the values that I assign to width and height by 300. So, I'll multiply the animation controller's value by 300, so that the height and width is maximum 300, minimum 0. A single click will start the animation. The AnimationController will generate values from 0 through 1. We multiply by that by 300 to get the height and width of our container. If you look at the animation values generated on the Run console, you can see that they are in the range 0 to 1.

I've multiplied these by 300 to set the height and width of our container. Turns out forward is just one way to play the animation. I'm now going to add in additional buttons to our app to allow us to play the animation forward, reverse, stop the animation, and reset the animation. Notice that I have the first ElevatedButton that says Animate that calls _animationController.forward. I have another ElevatedButton with the text Forward on its onPressed handler, I once again call _animationController.forward. So, both Animate as well as the Forward buttons play the animation forward from the start to the finish. But then, I've added three more buttons. I call _animationController.reverse to play the animation in reverse. That is, we'll go from 1 to 0 for the AnimationController values, so we'll shrink our circle. the Reset text calls _animationController.reset to reset the animation to its original state.
I have all of the buttons here at the bottom. The Animate button will simply grow my circle. The Reverse button will play the animation in reverse. My circle shrinks down to nothing. The Forward button also plays the animation forward. So, if you click on that, you'll see our circle grows up to its maximum size. Let's try the Reverse again. And this time, I'm going to Stop the animation midway, you can see that the circle has stopped shrinking. And the Reset button, of course, will reset the state of our app back to its original state.