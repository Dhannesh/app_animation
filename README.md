# Animation in Flutter

Flutter makes it very easy for you to work with animations using implicit animations.

These are implicitly animated widgets, where animations are managed by the Flutter framework. You don't have to do much. Many widgets that you commonly use in Flutter, such as containers, opacity, align, and so on have animated counterparts. **Animatable** widgets start with the Animated prefix and can be used just like their corresponding regular widgets. Except, of course, these can be animated, and the way you do it is you set the target value for an animatable property, and when the target value changes, the widget is automatically animated as it takes on this new value for the property, be it height, width, color, anything. Implicit animations allow you a whole range of animations that you can use. But sometimes, you might want more control over the animations, and then you may choose to use tween animations.

Tween here refers to in between. It's a short form for in between. And this is a kind of animation that gives the developer much more control. With tween animations, you specify the starting point for an animation, an ending point, and a curve to get from the starting point to the ending point. You use the curve associated with the tween to specify the timing as well as the speed of the animation. Here is a way to visualize how tweens work. Let's say, you have an object at its starting point and its ending point. Now, you have to think about how do you get from the start to end, that is the tween or the in between. Now, you might say that I want to get from the start to the end in a straight line. So, you'll generate values, so that the object is animated along the straight line.

Or you might say I want to get from the start to the end along a curve. In such a case, your tween would generate a different set of values, so that the animation progresses along this curve. When you use tween animations, the animation values allow you to specify the path from the starting point till the end. Tween animations use an object known as the AnimationController to control the animation when the animation starts, whether it can be stopped, whether it goes in reverse, and so on. Each animation has a status and a corresponding value. The value of an animation object can be thought of as the current value of the animatable property. So, let's say, you're animating the color to go from one shade to another, an intermediate value of the color property, well, that is the animation value.

The animation status has four possible states, ** dismissed, forward, reverse, and completed **. Every animation in Flutter uses an AnimationController. In the case of implicit animations, this AnimationController is hidden behind the scenes. You don't really interact with it as a developer. For explicit animations, you directly use the AnimationController. What can the AnimationController do? Well, it can help you define your animations. The AnimationController is also responsible for generating values that you can use to run your animation. The AnimationController allows you to register listeners for events and status changes.

And the AnimationController offers you play and other sequence controls for stop, reset, and so on. The AnimationController object is responsible for generating values that control the animation. By default, the AnimationController will only generate values between 0.0 and 1.0. But your use case or your scenario might have different beginning and end values. They may not be 0 and 1. And this is why in Flutter, you use an AnimationController along with a tween. AnimationControllers can use tweens to generate values that are specific to your use case, between 100 and 150, between red and blue, anything.

## Basic Animation

This MaterialApp (basic_animation) has a Scaffold. And its body property is set to the stateful widget called BasicAnimation. Now, let's take a look at this BasicAnimation stateful widget. you can see that BasicAnimation is a StatefulWidget. The state variables for this widget are just the width and height of the square that is displayed. Initially, I've set the width and height to be both equal to 50 pixels.  I have a Column widget, it has two children, an Expanded widget  and a Padding. Within the Expanded widget, I have a centered Container. Observe that the width and the height of this container are set using our state variables, _width and _height. Now, this container has alignment center and a BoxDecoration that sets the color of this container to lightGreenAccent, that is that box that you see at the center of the screen in the Emulator. This Padding widget contains within it a Row and this Row has two buttons within Expanded widgets. The first ElevatedButton is the Shrink button. Observe that I have a callback for the onPressed property. All I do when you click on this button is to reduce the width and height of the square.

This is our manual animation. Let's see how that works. I'm going to head over to the app and click on Grow several times. Each time I click on the Grow button, observe that the size of the square grows. So, it's kind of animated and it grows. This animation is not automatic, it's manual. Let's try shrinking the square. I'm going to click on Shrink several times, and you can see that the square gets smaller as I reduce its width and height.

It would have been much more fun if you could have used a slider to change the size of the square, that seems much more natural. I'm going to go ahead and update the code associated with this BasicAnimationState class to include a slider. You can see the slider at the bottom. That's what we'll use to grow and shrink the box. Now, let's take a look at the code here. Since I'm going to be animating a square, I decided to be a little more smart about it. I have a single member variable for the state class, that is the _sliderValue on line 37. I've set the _sliderValue to 50 to start off with.

## Progressing Towards Implicit Animations
It'd be really cool if all you had to do was click a button and the square would grow automatically to a certain size. You click another button, and the square would shrink automatically to a smaller size. Well, this is exactly what we are going to accomplish in the first part of this demo using a timer. And in the second part of this demo, we'll see how we can use implicit animations in Flutter to achieve the same thing in a much more simple manner.
First, let's update the code that I have here on screen. I'm going to update this BasicAnimationState class, so that I have a new UI setup. Now, this uses a timer, which means I need to add an import statement. So, I'm going to the top of my page here and add an import for dart:async.
The dart:async library has a timer utility that we can use to update the sides of our square at periodic intervals. With this done, let the app reload, so that you can see what the UI looks like. I have the same square, the light green accent square, and I have three buttons at the bottom, Shrink, Stop, and Grow. The Shrink button will shrink the square down to a minimum size. The Stop button will stop the shrink animation. The Grow button will grow the size of the square to a maximum size, and you can stop the growth as well using the Stop button. Let's take a look at what updates I've made to the code. The BasicAnimationState class now has a variable called side that is set to 50. In addition, it also holds a timer object that's defined on line 40 that's initially set to null.
The first button we'll look at is the Shrink ElevatedButton. Each time you click or press that button, we'll cancel whatever timer was previously running. If no timer was set up earlier, this cancel doesn't really do anything. I set up a new timer that will fire at regular intervals using Timer.periodic. The Duration that I pass into this timer is 100 milliseconds. This means that this timer will invoke the callback that I have specified every 100 milliseconds. And within the callback, all we do is call setState and decrement the side of the square by two pixels. 

I'll now scroll down a little bit further, and let's take a look at the Stop button. The onPressed handler simply updates the state of the timer. I call timer?.cancel() whenever we hit Stop. Cancelling the timer essentially stops the timer callback from being invoked and causes the box to stop growing or stop shrinking. and you can see how I wire up the grow button. This is the ElevatedButton. The onPressed handler basically first calls timer?.cancel(). So, whatever periodicity that we had set up earlier on the timer to grow or shrink, the box will be cancelled, and I set up a new periodic callback. Every 100 milliseconds the callback will be invoked, and all we do within the callback is call setState and decrement the size of the square by 2 pixels. Well, we've understood the code, let's see this in action.

### Implicit Animation
Let's see how we would accomplish the same growing and shrinking of our box using an implicit animation. Flutter widgets that support implicit animations that is built-in animations start with an animated prefix. So, if you have a container, an **AnimatedContainer** will support implicit animations. If you have a padding widget, AnimatedPadding will support implicit animations. An align widget, **AnimatedAlign** supports implicit animations. Let's take a look at our AnimatedContainer. Observe that I've set the width and height of the container to be equal to the side state variable. A new property, the duration. Here, I've set the duration to be 3000 milliseconds or 3 seconds. Now, what does this mean? In an AnimatedContainer, any time you change any of the properties of the container, and here we'll be changing the width and the height, it'll animate to the new set of properties. So, it'll animate to its new property value using the duration. So, here in our case, it'll animate to the new width and height in 3 seconds.

Whatever the current value of the side of the box, the AnimatedContainer will animate it to have a new side, which is equal to 20 pixels within 3 seconds. Notice the onPressed handler, where I set the state of the side variable to be 300. So, no matter the current size of the box, it'll animate to have a side of 300 within the duration specified, 3 seconds. With implicit animations, all you have to do is specify what you want the final value of a property to be and Flutter takes care of the animation. You don't have to do much.
