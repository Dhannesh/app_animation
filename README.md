# Animation in Flutter

Flutter makes it very easy for you to work with animations using implicit animations.

These are implicitly animated widgets, where animations are managed by the Flutter framework. You don't have to do much. Many widgets that you commonly use in Flutter, such as containers, opacity, align, and so on have animated counterparts. **Animatable** widgets start with the Animated prefix and can be used just like their corresponding regular widgets. Except, of course, these can be animated, and the way you do it is you set the target value for an animatable property, and when the target value changes, the widget is automatically animated as it takes on this new value for the property, be it height, width, color, anything. Implicit animations allow you a whole range of animations that you can use. But sometimes, you might want more control over the animations, and then you may choose to use tween animations.

Tween here refers to in between. It's a short form for in between. And this is a kind of animation that gives the developer much more control. With tween animations, you specify the starting point for an animation, an ending point, and a curve to get from the starting point to the ending point. You use the curve associated with the tween to specify the timing as well as the speed of the animation. Here is a way to visualize how tweens work. Let's say, you have an object at its starting point and its ending point. Now, you have to think about how do you get from the start to end, that is the tween or the in between. Now, you might say that I want to get from the start to the end in a straight line. So, you'll generate values, so that the object is animated along the straight line.

Or you might say I want to get from the start to the end along a curve. In such a case, your tween would generate a different set of values, so that the animation progresses along this curve. When you use tween animations, the animation values allow you to specify the path from the starting point till the end. Tween animations use an object known as the AnimationController to control the animation when the animation starts, whether it can be stopped, whether it goes in reverse, and so on. Each animation has a status and a corresponding value. The value of an animation object can be thought of as the current value of the animatable property. So, let's say, you're animating the color to go from one shade to another, an intermediate value of the color property, well, that is the animation value.

The animation status has four possible states, ** dismissed, forward, reverse, and completed **. Every animation in Flutter uses an AnimationController. In the case of implicit animations, this AnimationController is hidden behind the scenes. You don't really interact with it as a developer. For explicit animations, you directly use the AnimationController. What can the AnimationController do? Well, it can help you define your animations. The AnimationController is also responsible for generating values that you can use to run your animation. The AnimationController allows you to register listeners for events and status changes.

And the AnimationController offers you play and other sequence controls for stop, reset, and so on. The AnimationController object is responsible for generating values that control the animation. By default, the AnimationController will only generate values between 0.0 and 1.0. But your use case or your scenario might have different beginning and end values. They may not be 0 and 1. And this is why in Flutter, you use an AnimationController along with a tween. AnimationControllers can use tweens to generate values that are specific to your use case, between 100 and 150, between red and blue, anything.

## Basic Animation

This MaterialApp (basic_animation) has a Scaffold. And its body property is set to the stateful widget called BasicAnimation. Now, let's take a look at this BasicAnimation stateful widget. you can see that BasicAnimation is a StatefulWidget. The state variables for this widget are just the width and height of the square that is displayed. Initially, I've set the width and height to be both equal to 50 pixels.  I have a Column widget, it has two children, an Expanded widget  and a Padding. Within the Expanded widget, I have a centered Container. Observe that the width and the height of this container are set using our state variables, _width and _height. Now, this container has alignment center and a BoxDecoration that sets the color of this container to lightGreenAccent, that is that box that you see at the center of the screen in the Emulator. This Padding widget contains within it a Row and this Row has two buttons within Expanded widgets. The first ElevatedButton is the Shrink button. Observe that I have a callback for the onPressed property. All I do when you click on this button is to reduce the width and height of the square.

This is our manual animation. Let's see how that works. I'm going to head over to the app and click on Grow several times. Each time I click on the Grow button, observe that the size of the square grows. So, it's kind of animated and it grows. This animation is not automatic, it's manual. Let's try shrinking the square. I'm going to click on Shrink several times, and you can see that the square gets smaller as I reduce its width and height.

It would have been much more fun if you could have used a slider to change the size of the square, that seems much more natural. I'm going to go ahead and update the code associated with this BasicAnimationState class to include a slider. You can see the slider at the bottom. That's what we'll use to grow and shrink the box. Now, let's take a look at the code here. Since I'm going to be animating a square, I decided to be a little more smart about it. I have a single member variable for the state class, that is the _sliderValue on line 37. I've set the _sliderValue to 50 to start off with.

## Progressing Towards Implicit Animations
It'd be really cool if all you had to do was click a button and the square would grow automatically to a certain size. You click another button, and the square would shrink automatically to a smaller size. Well, this is exactly what we are going to accomplish in the first part of this demo using a timer. And in the second part of this demo, we'll see how we can use implicit animations in Flutter to achieve the same thing in a much more simple manner.
First, let's update the code that I have here on screen. I'm going to update this BasicAnimationState class, so that I have a new UI setup. Now, this uses a timer, which means I need to add an import statement. So, I'm going to the top of my page here and add an import for dart:async.
The dart:async library has a timer utility that we can use to update the sides of our square at periodic intervals. With this done, let the app reload, so that you can see what the UI looks like. I have the same square, the light green accent square, and I have three buttons at the bottom, Shrink, Stop, and Grow. The Shrink button will shrink the square down to a minimum size. The Stop button will stop the shrink animation. The Grow button will grow the size of the square to a maximum size, and you can stop the growth as well using the Stop button. Let's take a look at what updates I've made to the code. The BasicAnimationState class now has a variable called side that is set to 50. In addition, it also holds a timer object that's defined on line 40 that's initially set to null.
The first button we'll look at is the Shrink ElevatedButton. Each time you click or press that button, we'll cancel whatever timer was previously running. If no timer was set up earlier, this cancel doesn't really do anything. I set up a new timer that will fire at regular intervals using Timer.periodic. The Duration that I pass into this timer is 100 milliseconds. This means that this timer will invoke the callback that I have specified every 100 milliseconds. And within the callback, all we do is call setState and decrement the side of the square by two pixels. 

I'll now scroll down a little bit further, and let's take a look at the Stop button. The onPressed handler simply updates the state of the timer. I call timer?.cancel() whenever we hit Stop. Cancelling the timer essentially stops the timer callback from being invoked and causes the box to stop growing or stop shrinking. and you can see how I wire up the grow button. This is the ElevatedButton. The onPressed handler basically first calls timer?.cancel(). So, whatever periodicity that we had set up earlier on the timer to grow or shrink, the box will be cancelled, and I set up a new periodic callback. Every 100 milliseconds the callback will be invoked, and all we do within the callback is call setState and decrement the size of the square by 2 pixels. Well, we've understood the code, let's see this in action.

### Implicit Animation
Let's see how we would accomplish the same growing and shrinking of our box using an implicit animation. Flutter widgets that support implicit animations that is built-in animations start with an animated prefix. So, if you have a container, an **AnimatedContainer** will support implicit animations. If you have a padding widget, AnimatedPadding will support implicit animations. An align widget, **AnimatedAlign** supports implicit animations. Let's take a look at our AnimatedContainer. Observe that I've set the width and height of the container to be equal to the side state variable. A new property, the duration. Here, I've set the duration to be 3000 milliseconds or 3 seconds. Now, what does this mean? In an AnimatedContainer, any time you change any of the properties of the container, and here we'll be changing the width and the height, it'll animate to the new set of properties. So, it'll animate to its new property value using the duration. So, here in our case, it'll animate to the new width and height in 3 seconds.

Whatever the current value of the side of the box, the AnimatedContainer will animate it to have a new side, which is equal to 20 pixels within 3 seconds. Notice the onPressed handler, where I set the state of the side variable to be 300. So, no matter the current size of the box, it'll animate to have a side of 300 within the duration specified, 3 seconds. With implicit animations, all you have to do is specify what you want the final value of a property to be and Flutter takes care of the animation. You don't have to do much.
## Building Implicit Animations with AnimatedContainer
We'll use an implicit animation on this AnimatedContainer (animated_container1.dart), which has set the background to change the color of the background. When we click on the floating action button, we'll toggle between the red to the green color and then from green back to red. MyAnimatedContainer is a stateful widget.The only state variable is the Color variable initially set the color to be red. And this is something that we'll update using an implicit animation. this AnimatedContainer spans the entire screen, that's why I haven't specified a height and width. The color of this container is set using the color state variable. And I've set the duration property to 2500 milliseconds. So, whatever animation is applied to this container will basically take place over 2.5 seconds.
The animation will be triggered by the floatingActionButton.  All it does is call setState. Ensuring that the animation progresses nicely from green to red and from red to green, well, that's up to Flutter. If you want to configure how fast or slowly your animation runs, you can change the duration. Notice I've set the properties width, height, and color using the state variables, and the duration of the animation is once again 2500 milliseconds or 2.5 seconds.

I'll scroll down and let's take a look at the floatingActionButton that will trigger the animation. The onPressed handler of this floatingActionButton updates the state of the container. If the width was originally equal to 50, we'll set the width to be the width of the entire screen that we access using MediaQuery.of(context). If the width is not 50, we set it to 50.  We do something similar with the height. I now have a small red box at the center of my screen. I'm going to click on the floating action button, and this should now basically change color as well as grow to fill up the entire screen. Animating multiple properties is kind of fun. I'll click on the floating action button once again, and you should find that the container shrinks to be a smaller size and red in color. Play around with this. You see that implicit animations make it very easy for you to animate your widgets.

## Configuring Animation Curves
Now, the width and the height of the container are animated, and they're set using the state variables width and height. I set the color of the container. But because the container holds an image. The image embedded within this container is an AssetImage. It's images/tie. a jpg file that I've placed within the images subfolder. Make sure you have the right entry in the pubspec.yaml file to ensure that you can access these image assets. I set the duration of the animation on this container to 2.5 seconds or 2500 milliseconds. Observe that the onPressed handler is the same as before. I changed the width to fill up the screen if it's 100 or I shrink it to a 100. I change the height to fill up the scene if it's equal to a 100, otherwise I shrink it to a 100. And I change the color from red to green and back. The main difference here is that our container holds an image. I'm going to click on the floating action button, and you can see that the container grows and the image, kind of, has a zoom-in effect. And I click on the floating action button again, the container shrinks. Now, so far, all of our animations on the container have been linear animations. That is, the animation changes linearly over time.
https://api.flutter.dev/flutter/animation/Curves-class.html.
So, if the animation is over say 3 seconds, the rate of change of the animated property is constant over all three seconds. But this need not be the case. You can actually control how the animation changes over time.
the way you do this is by using the **Curves class**.

Now, here is the Flutter documentation documenting the different types of curves that you can use with implicit animations. For each curve along the x-axis, we have the rate of change of time. Along the y-axis, we have how the property X that you are varying changes. And just a glance at this page will show you all of the different curves that are available, the **bounceIn**, the **bounceInOut**, the **bounceOut**, the **decelerate**, the **accelerate**. All these different curves can help you make your animations more interesting. Now, by default, all Flutter animations use the linear curve. So, I'm going to click on Curves.linear, and you'll see how the animation progresses linearly over time. Now, this is quite fine, but some other curve might be more interesting. Let's click on Curves.elasticIn, and you'll see how it kind of has an elasticity bouncy quality.

This is how your animation will progress. I suggest you play around with the curves on this page to get an idea of how you can have your animations progress, easeInOutBack, easeOut. All of these are curves that you can use with your animations in Flutter. Now, let's switch back to our code and try out a few different animation curves. And the way you set up curves for your animation is very straightforward, simply set the curve property on your implicitly animated widget. I'm going to click on the floating action button here, and this is how the animation progresses. Let's click on the button once again and shrink our image back. And you can see that the progress is very slow at the middle of the animation and fast at the beginning and the end. Let's try one last curve, the easeInBack. Observe how the image grows, it shrinks and then expands to its final size. Let's click on the button once again, and you can see that it kind of pulls out and then shrinks to the smaller size.

## Controlling Multiple Animations
I've already set up the code for multiple animations in the multiple_animation_container.dart file, you can see that within an app page, we have two different images. The image on top is of a top, a dress top, and the image at the bottom is an image of jeans. In our first iteration of this code, let's see how the animations work. I'm going to click on the play button here. Observe that both images shrink together and if you click on the same play button again, you can see that both images grow again together simultaneously. Let's take a look at the code to actually wire up these animations. We can look at the state class for this AnimatedContainerPage. Observe the state member variables. I have the ViewState that is initially set to expanded. 

Let's take a look at the two animated containers. This is the AnimatedContainer for the image on top. You can see that the width and height of the container are set based on the _viewState. If the ViewState is expanded, we set the width and height to be equal to the _expandedSize. If it's shrunk, then we set it to be equal to the _shrunkSize. The image within the container is specified as a DecorationImage.

I'm going to scroll down further, so you can see the second AnimatedContainer. You can see that its properties are exactly the same as the first, width and height are based on _viewState, The DecorationImage  displays a number of pairs of jeans. The duration once again is 3 seconds and the curve is linear and further down, the floatingActionButton that triggers the animation simply calls setState within its onPressed handler. It changes the _viewState. If the _viewState was originally expanded, it sets it to ViewState.shrunk, otherwise it sets it to ViewState.expanded.

When you click on the floating action button, the images will shrink simultaneously. And you click on the button once again, they'll expand simultaneously. I think these animations are kind of boring. 

Let's tweak a few properties to make them more interesting. My objective here is to chain the two animations together, so that the container on top is animated first. And after that, we animate the container with the jeans image at the bottom. The first thing I need to set up to achieve this is to have different state variables for the top view and the jeans view. I have two ViewState variables, the _topViewState and the _jeansViewState. Both of them are initially set to shrunk. The **onEnd** callback will be invoked when the animation for this container has ended. Now, within the onEnd callback, I call setState to update the ViewState for the jeans image. If the _jeansViewState was originally expanded, I'll go ahead and set it to the shrunk ViewState, otherwise I'll set it to expanded. So, the _jeansViewState is only updated after the animation for the top container is at its end.

A last change that I have made here is that of floatingActionButton. On its onPressed handler, I call setState, but I only update the state for the top container. you can see that if the _topViewState is expanded, I set it to shrunk, otherwise I set it to expanded. for the top container ends, that will automatically trigger the animation for the bottom container. Let's try this. I'm going to click on the button to trigger the animation. The top container gets animated first, and then the bottom container is animated after that. Let's try this again. The top container will shrink first, and the bottom container will expand after that. Thus, by having different states for the two containers and using the properties available on the AnimatedContainer, we have chained together animations to give a much more interesting effect.

## Using AnimatedOpacity and AnimatedCrossFade
The AnimatedOpacity. As its name suggests, the AnimatedOpacity widget allows us to animate the opacity of any widget that it wraps. Animating the opacity allows you to set up a peekaboo effect in your code, where you perform some kind of gesture, and then suddenly you see something pop-up or another gesture makes it disappear, hidden from view. The _opacity is initially set to 0.0. An _opacity of 0.0 means the element is fully transparent, that is, it is invisible.

The actual layout of the user interface is in the build method. Within the body of the Scaffold, you can see that I have an InkResponse widget. Remember the InkResponse responds to tap gestures and each time you tap on it, it'll give you a highlight effect and that's why I've used the InkResponse. The onTap handler, when you click on this InkResponse widget, simply changes the state of your _opacity. If _opacity was previously 0.0, it'll set the _opacity to 1, otherwise it'll switch the _opacity back from 1 to 0.0. 
This Container contains a Column widget. And if you look at the first child of the Column widget, you see that child is either a Text that says Tap me! when _opacity is 0, otherwise it's just a Container. Essentially, this means when the underlying widget is invisible, has an _opacity of 0, you'll be able to see the Text that says Tap me! Otherwise, you'll just see a Container, which has no color, is completely transparent. That means you'll be able to view the underlying widget that's wrapped in an AnimatedOpacity widget.
Now, that we understand the code, let's go ahead and run this app and see how it works. I'm going to go ahead and tap on this box that says Tap me! And you should find that the _opacity changes over the course of a second. The underlying image and text goes from being transparent to opaque, and you can now see what's underneath an image and a congratulatory message saying you get some percentage off on your order.

you can see in animated_cross_fade_page.dart that it has one Boolean state variable, _showFirst set to true. This is the variable that I'll use to track which widget is being displayed. _showFirst set to true means that I'll display the first widget on screen first, and then when the user taps on it, I'll display the second. I'll update the state to do so.
Let's go straight to the **AnimatedCrossFade** widget. You specify the children of the AnimatedCrossFade using two properties, firstChild and secondChild. The firstChild property is an InkWell, which means it responds to a tap gesture. And the InkWell contains within it a Card material widget that contains an Image. So, essentially, this firstChild is a widget that responds to tap gestures and shows some kind of highlighting on the tab and contains an image. What's interesting here is the onTap handler. All I do here is call setState and toggle the _showFirst Boolean. If _showFirst was originally true, it will be set to false. If it was false, it will be set to true.
The secondChild for this AnimatedCrossFade widget is also an InkWell that responds to tap gestures. The InkWell wraps a Card widget , which then further wraps an Image. The onTap handler for the InkWell also updates the _showFirst variable. It toggles it. If it was true, it will be set to false. If it's false, it'll be set to true.

So, essentially, you can tap on both of the widgets displayed by the AnimatedCrossFade, and the crossfade should animate between the two children. There are a few more properties that you need to set. The crossFadeState property tells this widget whether the firstChild should be displayed or the secondChild should be displayed. If showFirst is true, set the CrossFadeState to showFirst, otherwise set it to showSecond. And the duration of this animation is just 1 second.

## Playing with the AnimatedSlide
you'll see that the only state variable that this particular animated_slide_page.dart state has is the Offset. The offset is originally set to Offset.zero. An offset is an immutable two-dimensional floating point offset and can be used as a vector that can be applied to coordinates. I have the _slideLeft and _slideRight methods. Notice within _slideLeft, I subtract (1, 0) from the original offset. This means I'll decrement the X value by 1, so the car will move to the left. _slideRight increments the offset by an Offset value of (1, 0), which means I increment the X value by 1, so the car will move one unit to the right. 

If you scroll down, you'll see that our AnimatedSlide simply holds an Image. This Image  is an image of a car and it's available in the images folder. This should be part of the resources that you have for this video. The AnimatedSlide animates the offset property that is set using the state variable and the duration for this animation is 1 seconds. The first ElevatedButton's onPressed handler will slide the car left. The second ElevatedButton's onPressed handler will slide the car right.

All that's left is to run the app and play around with the AnimatedSlide. I'm now going to click on the different buttons at random. Let's start with the _slideUp. You'll see that the car will give a bouncing motion before it moves up. The _slideDown brings the car back down to its original position. So, if you click on the button multiple times, it will, of course, move further along in that direction. And you can, kind of, click on them quickly, and you'll find that the car moves to different positions in the screen.

## Using the Animation Controller
In Flutter, every animation is controlled using an **animation controller**. It's just that in the implicitly animated widgets that we've worked with so far, the animation controller is behind the scenes handled by Flutter. We don't interact with it directly. But if you want to use tweening and other advanced animation effects.
The animation controller is what allows you to control and manipulate your animation. It lets you perform tasks, such as playing an animation in forward or reverse, stopping an animation, defining bounds for your animation, and so on. 

The AnimationController, by default, linearly produces values that range from 0.0 to 1.0 within the duration. So, within the 2.5 seconds of the animation, the AnimationController will generate values from 0 to 1. These generated values from 0 to 1 are given to your app whenever your device is ready to display a new frame.

A TickerProvider is basically just a factory to create Ticker objects. And a Ticker object knows how to register itself with a scheduler and then fire a callback for each frame, so that your animation can be updated for each frame. The AnimationController actually uses this TickerProvider to step through the animation that it controls. Another interesting detail of the Ticker objects that you need to keep in mind is that these Ticker objects only tick when the current tree is enabled. So, if your widgets are disabled or hidden, they will not tick. That means your animations will not take up compute resources.

Now, this AnimationController constructor has the red underline because it asks for the vsync argument, and the vsync argument is a reference to the TickerProvider. So, where do we get this TickerProvider from? Well, we use a mixin. I'm going to update this State class, so that it extends the state and uses a mixin, so with SingleTickerProviderStateMixin. And really, with this mixin, you have the TickerProvider that your AnimationController needs. The SingleTickerProviderStateMixin is the right one to use if you have just a single AnimationController in your class. For multiple animation controllers, you need to use a different class, the TickerProviderStateMixin.

Now, remember that our AnimationController needs access to this TickerProvider and we pass an instance of the current object to the vsync property in the _animationController constructor. The vsync property is set to this, the current instance of the state object. Now, remember that your AnimationController is controlling and managing your animations. it's very important that you dispose off the AnimationController in the dispose method of your StatefulWidget as I've done here within the dispose method.

The AnimationController, when activated, will generate values between 0 and 1. Now, these values are accessible in the value member variable of the AnimationController. It turns out that the setState method does not really need to actually change the state.  I call _animationController.addListener. And as the AnimationController value changes, this listener will be invoked. And within the listener, I call setState and all I do within setState is print out the current animation value. I only print out the value generated, I'm not actually changing any other state. setState will automatically redraw the widget, which will take the new values from the AnimationController for the height and width. AnimationController generates values between 0 and 1. But if our shape has height and width of 0 and 1, well, we won't really be able to see anything, it will be too tiny. So, I'm going to scale the values that I assign to width and height by 300. So, I'll multiply the animation controller's value by 300, so that the height and width is maximum 300, minimum 0. A single click will start the animation. The AnimationController will generate values from 0 through 1. We multiply by that by 300 to get the height and width of our container. If you look at the animation values generated on the Run console, you can see that they are in the range 0 to 1.

I've multiplied these by 300 to set the height and width of our container. Turns out forward is just one way to play the animation. I'm now going to add in additional buttons to our app to allow us to play the animation forward, reverse, stop the animation, and reset the animation. Notice that I have the first ElevatedButton that says Animate that calls _animationController.forward. I have another ElevatedButton with the text Forward on its onPressed handler, I once again call _animationController.forward. So, both Animate as well as the Forward buttons play the animation forward from the start to the finish. But then, I've added three more buttons. I call _animationController.reverse to play the animation in reverse. That is, we'll go from 1 to 0 for the AnimationController values, so we'll shrink our circle. the Reset text calls _animationController.reset to reset the animation to its original state.
I have all of the buttons here at the bottom. The Animate button will simply grow my circle. The Reverse button will play the animation in reverse. My circle shrinks down to nothing. The Forward button also plays the animation forward. So, if you click on that, you'll see our circle grows up to its maximum size. Let's try the Reverse again. And this time, I'm going to Stop the animation midway, you can see that the circle has stopped shrinking. And the Reset button, of course, will reset the state of our app back to its original state.

## Using the AnimatedBuilder
you'll see how we can use an **AnimationController** along with an **AnimatedBuilder** widget. An AnimatedBuilder is a general-purpose builder for building animations. And it's generally used for more complex widgets that wish to include an animation as a part of a larger build function. I have the Animate button and the Stop buttons at the bottom. The body of the Scaffold is set to the StatefulWidget called AniBuilder. I have initialize this controller within its initState method. It'll run for a duration of 2.5 seconds, and the vsync argument is passed in as the current instance of the stateful widget this. This stateful widget uses the SingleTickerProviderStateMixin. And that's why you can pass this widget in as an instance for vsync. Make sure that you dispose off the _animationController in the dispose method. 

Observe that you set the animation property to the _animationController indicating that it's this controller that's controlling this builder widget. Well, its child, you can see is a SizedBox with width and height both set to 300, and it contains an embedded image of a toy ducky. Our animation is going to grow and shrink the size of this toy duck, and we'll do this in an interesting and performant efficient way. We won't change the property of the SizedBox or this Image. The interesting stuff that we do here is in the builder function, and that is set to the builder property. The builder is a callback that you use to build your widget tree at every frame of the animation. If it so happens that the subtree that you're animating does not change in every animation frame, it's very efficient to build that subtree exactly once instead of rebuilding it on every animation tick. So, you prebuild the subtree and you reuse it each time.  I use Transform.scale to change the size of the toy duck that we're going to display. So, I set the scale factor based on the animation controller's value. The image of the duck itself does not change, only the scale factor, and that's why I set the child property of this Transform.scale to the child of my AnimatedBuilder. So, here I'm not rebuilding the child subtree on each animation, I'm simply reusing an already prebuilt subtree and this will make my animation more performant. Reusing this prebuilt child is entirely optional, but it does make your animation and your app much more efficient.  If you want your animations to run over and over again, instead of calling forward, you can call _animationController.repeat. That's what I've done here within the onPressed handler of the Animate button.
if you want the animation to repeat and play in reverse? Invoke the repeat method and pass in (reverse: true).

Let's change the transformation that we applied to our duck. I'm going to import the dart:math library. I'm going to need the pi value from the math library. Within the builder function, instead of using Transform.scale, I'm going to use Transform.rotate.
For the rotate transformation, I specify the angle: 2 * pi multiplied by the animation controller's value. 2 * pi is equal to one full circle, so this will rotate our duck one full circle. Let's change our animation controller back to forward. So, each time we hit Animate, our duck should rotate once.
Let's go ahead and restart our application and see our rotating duck. Now, I'm going to click on the Animate button, and you'll see that the duck rotates exactly once. Now, if I click on the Animate button once again, the duck does not rotate. Well, that's because the animation controller's value is now 1. So, once it's 1, it can't go from 0 to 1 once again, unless it's reset. Let's reset the animationController once the animation is complete. And you can do this using a StatusListener. You can add a StatusListener callback to the animationController, and this will be invoked each time the animation status changes, when it begins, when it ends, and so on. Within the StatusListener, if the status of the current animation is completed, I call animationController.reset. Let's reload the app and get started. So, each time I click on the Animate button, the duck will rotate exactly once. Once the animation is complete, the controller has been reset, so I can click on Animate once again and the duck will rotate again.

## Creating Animations using Tweens
In this demo, you'll see how you can use tweens along with your AnimationController. Now, one pain point that everyone faces when using the AnimationController directly is the fact that the values that the AnimationController generates are between 0 and 1, which means you need to scale these values by a factor to make sure that the values fit your use case, whatever animation you are trying to set up. Tweens are a short form for in between and tweens allow you to generate values that are an interpolation between a starting point and an ending point.

Tweens are used along with an AnimationController. I'll show you how you can grow and shrink the size of a circle using a tween rather than just an AnimationController. You can see the animation property is set to the _animationController. 

The Animate button simply calls _animationController.forward, and the Reset button calls _animationController.reset, so we can replay the animation as needed. Let's now perform this animation using tweens. Now, tweens create an animation object when you invoke animate on a tween and pass in a controller. We'll save this animation object in this Animation variable. Observe that this Animation object is parameterized by type double because we are going to have our tween return double values within a range.

Let's now set up our _animation object using a tween. Here, I use Tween parameterized by type double, and begin and end tells the Tween in what range we want our values to be generated. We want our values to start at 50 and end at 300. We instantiate the Tween and invoke the animate method and pass in the _animationController to get an animation object.

Now, that we have an animation object, our Container should not get its height and width values from the animationController. Instead, it should get it from the animation object. So, we access the value property of the animation object. This will give us the height and width values in the right range, 50 to 300. Your animation is still controlled using the animation controller's forward, reset, reverse methods, but you can now use the animation's value.

Now that you've harnessed the power of tweens, you can use tweens to animate multiple properties in one go. I'm going to set up another animation variable, this time for color. the _colorAnimation object, which will allow us to animate between different shades of color for our circle, is of type Animation parameterized by Color. So, within the BoxDecoration, instead of having one static color, I'll set the color using _colorAnimation.value. Now, having made these changes, let's see how our multiple animations using tweens work. Let's restart the app. I'm going to click on Animate, and you can see that as the circle grows, it becomes cyan in color. Let's click on Reset, we'll get a smaller circle in the lightGreenAccent color once again. And clicking on Animate will grow the circle as well as change its color.

## Tween Animations in a Real-world Scenario
We'll use an AnimationController along with tweens to achieve an animation effect that might make sense in a real-world scenario.You can see this represents a wallet, and there is a button that says Top Up. When we click on Top Up, I'm going to animate the dollars present in the wallet, so that it tops up to the final value. And then, the wallet will be displayed in green. I'll set the home property to MyWallet, that is a StatefulWidget. Within the State class of this widget,which uses the SingleTickerProviderStateMixin, you can see that I have a static const defined. This is the walletBalance, which is equal to 500. Whenever we top up our wallet, we'll add in $500. 

I'll use the initState method to set up this AnimationController. The vsync property is set to the current instance of this state class. The duration of the animation is 2 seconds. And I've also added in a Listener to call setState. This will ensure that the state of this widget updated each time the animation value changes. I also use a Tween to generate values for this AnimationController. The begin balance is 0.0. The end balance is equal to the walletBalance that is currently $500.
A fairly simple animation to give you a great real-world effect. I'm going to click on Top Up, observe how the numbers in my wallet go up, up to 500 and the wallet is now in green, indicating I have money in there. Let's change our wallet, so that we top up to a walletBalance of a $1000. If you have money in your wallet, you can spend it. If you don't, then you have to top it up. Notice that I've changed the Text on my ElevatedButton. If my controller.status says animation is completed,then the text on the button will be Spend. Otherwise, it will be Top Up. I've also changed the onPressed handler. If the controller.status is animation is complete, then the controller goes in reverse. That's means that we have money in our wallet, and then we can spend that money. Otherwise, the controller moves forward.

## Staggered Animations
You can use a single AnimationController to animate multiple objects, but by default the animations run at the same time. In this demo, we'll see how staggered animations can be set up. A staggered animation consists of several animations that can be played in sequence or these animations can also overlap in time. I have the play button that is the floatingActionButton. When I click that, the profile and the top bar on my profile page will come into view. You can see that it contains an AnimationController and initialized this AnimationController in the initState method. This animation will run for 2 seconds, I actually build up the profile page in a different file. You can see within the build method of the stateful widget, I have the body set to the ProfilePage, and I pass in the AnimationController that I have initialized to the ProfilePage. The floatingActionButton is defined right here. Its onPressed handler resets the controller and then invokes forward on the controller.

The constructor for the profile page accepts an AnimationController as an input argument. it uses the animation controller to instantiate a custom object of type ProfilePageEnterAnimation. 
The controller for this AnimatedBuilder is available in the custom animation class animation.controller. That's the one that was passed in as the constructor for this widget. The builder function simply sets up the widget tree of this page. Now, because this widget tree is going to change based on the animation, we can't basically use a prebuilt widget. Now, this widget tree contains a Stack with two children, a topBar and a circle. Now, I've used methods to set up the individual widgets, so you can clearly see how the widgets are laid out. The topBar method will display the bar, that kind of animates downwards. And the circle method sets up the widget that has the profile photo. The topBar method accepts as an input argument the animation value from animation.barHeight. And the circle accepts as an input argument the animation value from animation.avatarSize.

The profile photo is what this circle function creates. This is essentially a Container with a circular shape to which we are applying a Transform. I use Matrix4.diagonal3Values. This is used to create a three-dimensional matrix with x, y, and z values.

Both x and y values I've set to the animationValue that will be generated from the AnimationController. The z value I've just set to 1. You're not animating the z-axis, we're only animating the x and y-axis, so that the profile photo kind of grows in. And then, finally here at the bottom, we have the custom profile page, EnterAnimation object.

You can see that it has three member variables, the AnimationController, an Animation for barHeight, and an Animation for avatarSize. barHeight, initialized is set up using a Tween parameterized by a double value beginning at 0 and ending at 150 pixels. we invoke the animate method, pass in the controller to get the animation object. The avatarSize is also an animation created using a Tween<double> beginning at 0 and ending at 2. This is the code that produced the animation you saw at the beginning of the video. I'm going to click on the play button, observe how the top bar animates downwards and the profile photo animates along the x and y-axis. Rather than have the animations play simultaneously, what if I want to play them in sequence? What if I want to overlap them for only a small period of time? Well, we'll use staggered animations for this. Staggered animations require the use of a CurvedAnimation class. The CurvedAnimation is useful when you want to apply a non-linear curve to an animation object. Curved animations also allow us to specify intervals. Observe when I pass in the controller to the animate method, I wrap it in a CurvedAnimation.  I have set the curve to be an Interval. This animation will run in the interval 0 to 0.5, that is in the first half of the entire duration of the animation, and it will use the easeIn curve. Think of the entire duration of your animation as being from 0 to 1. This first barHeight animation will run for the first 50%. Now, let's set up the staggered animation for the avatarSize as well. 

The two animations overlap. The first animation runs for the first 50%. The second animation runs for the last 80% of the duration of the original animation. 

## Hero Animations for Smooth Transitions
Hero animations in Flutter refer to a kind of transition known as shared element transition. Let's say you're looking at an image or a certain widget on one page, and then when you click on that widget, that same image pops up in a more detailed view on the second page. Now, if you want that widget to be animated as you transition from one page to another, such a transition is a Hero Animation.
Every Hero widget has to be associated with a tag. It's this tag that identifies the Hero. I've set the tag to toy. This tag has to be unique for every Hero widget that you have within a page, and this same tag has to be present in the Hero widget on the second screen.

## Hero Animations for Grid Elements
Hero animations make much more sense when you're viewing a number of elements, maybe in a list view or a grid view, and then you select a certain element and get into the details page. And the icon or image associated with that element animates onto the new page, and that is the Hero widget.
I have a list of products that I have defined. All of these products are toys. Note that every product has an image reference to an image in the images subfolder, those are part of my assets, as well as a title. These are the products that I display in the grid format. 
I've specified some padding. And then, I have a gridDelegate that says that the crossAxisCount will be 2. That is, I'll display 2 products for every row, and then I've set some crossAxisSpacing and mainAxisSpacing. I then construct the grid view using a SliverChildBuilderDelegate that takes in a context and an index for each grid item that we want to set up. Each grid item is a Stack widget, which contains an Image. I use the ModalRoute to access the arguments Map. I've received an object of the product class as an argument to this page.  I reference the imageName for this product and display that as an image in this ProductDetails view. You have to uniquely identify your Hero widgets, so the animations can be set up correctly. I've set the tag to be equal to the title of the product. Each product has a unique title, so I can use the title as a tag for the Hero widget. Remember the tag has to be unique for each Hero widget in our grid. I'll click on the Ball and well, got animated but it was hard to see. The hero animations during navigation go by quite fast. 

We can actually view these navigations more clearly if we slow down the navigation transition. And in order to configure the transition time between page navigation, you need to use the page route builder rather than the material page route. you'll see that the onPressed handler of the ElevatedButton navigates to the product_details page using a PageRouteBuilder. The PageRouteBuilder accepts a transitionDuration and a reverseTransitionDuration. I've set the Duration to 5 seconds, so you can clearly see how the hero animation works. I use the RouteSettings to pass in my argument to the next page, that is the current product that is being selected that is to be displayed in the product_details page. I'll now switch over to the product_details page and add in the Hero widget here as well. So, here is our text, which shows the title of the toy. I've replaced it with the Hero widget. The tag says Text- and then the title of the toy.

If you want to show a different intermediate widget, you can use the flightShuttleBuilder property on your Hero widget.

## Implementing Physics Simulations
we'll see how you can work with physics simulations in Flutter. Now, we've seen a variety of animations that Flutter supports. Physics simulations allow you to animate your objects in a more realistic manner that follows the laws of physics. For example, you can mimic a falling object, which is pulled down by gravity, or you can mimic an object being attached to a spring and it's springing up and down, or you can mimic friction. In order to use physics simulations, I have an import statement to import the flutter/physics.dart package. The home property of my MaterialApp is set to PhysicsAnimation, which is a StatefulWidget.

I have the class PhysicsAnimation that extends the State base class and includes the SingleTickerProviderStateMixin. Now, this class has an AnimationController and this class uses the GravitySimulation, and you can see the simulation object, within the initState method , I set up the GravitySimulation. This takes in four input arguments, the acceleration in pixels per second square, the starting point which is a 0.0, the end point which is at 650 pixels, and the starting velocity which is again 0. I've set up the AnimationController and wired up a Listener that simply calls setState to update the state of this widget. And since I have an AnimationController, I have to ensure that I dispose off it, and I do this in the dispose method.
The first Positioned child is an image of a stone to animate the stone falling due to gravity, I'll set the top property of this Positioned widget using the animation controller.  I've set the top property to _controller.value. The second Positioned widget is fixed at the very bottom of the screen and this is just an image of some grass, so our stone falls onto this grass. We'll kick start the animation when the user clicks on the floatingActionButton. It's onPressed handler calls _controller.animateWith and passes in the GravitySimulation.

